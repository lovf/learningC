//指针进阶例题整理:
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//问题1:
#include <stdio.h>
#include <stdlib.h>

int main () {
	int a[5] = { 1, 2, 3, 4, 5 };
	int* ptr = (int*)(&a + 1); //&a得到一个数组指针,数组指针+1 跳过整个数组(&a + 1)  int(*)[5] 然后在强转为(int*)
	printf("%d,%d\n",*(a+1),*(ptr-1)); //2,5


    system ("pause");
    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//问题2:
#include <stdio.h>
#include <stdlib.h>

struct Test{

	int Num;
	char* pcName;
	char cha[2];
	short Sba[4];

};

int main () {
	struct Test* p = (struct Test*)0x100000;
	//printf("%p\n",p+0x1); //已知结构体占20个字节(十六进制对应14) 等于结构体跳过一个元素 100014
	//结构体占20个字节的大小 %p 代表打印一个指针变量的内容(地址),习惯上用16进制表示.
	printf("%d\n",(unsigned long)p+0x1); //100001 p本来是一个结构体指针,但是(unsigned long)p等于将p强转为长整数型,整数+1只是单纯的+1;
	//(unsigned long)p p+1,等于整数+1,不会存在指针的类型.
	printf("%d\n",(unsigned int*)p+0x1); // 0x100004 p本来是一个结构体指针,但是(unsigned int*)p等于将p强转为无符号的指针类型p+1类似于地址+4
	//对于(unsigned int*)p 假如P+1,(类似于指针+1)等于跳过一个元素(unsigned int 占4个字节的大小)
    system ("pause");
    return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//问题3:
#include <stdio.h>
#include <stdlib.h>

int main () {
	int a[4] = { 1, 2, 3, 4 };
	int* ptr1 = (int*)(&a + 1);
	int* ptr2 = (int*)((int)a + 1);
	printf("%x,%x\n",ptr1[-1],*ptr2);

    system ("pause");
    return 0;
}
//1  2   3   4的十六进制数对应的  |01  00  00 00 |02 00 00 00 |03 00 00 00 | 04 00 00 00 |

&a得到一个数组指针(类型int(*)[4]),然后又通过int*进行强转
(int)a意思是将a强转成整形,(int)a+1等于首元素的地址加一个整数,从+1的位置开始往后数.   (这块一定分清楚指针+1和整数+1的区别)
*ptr2 意思是+1的位置开始往后数,找到4个字节大小的位置即可.
///
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//问题4:
#include <stdio.h>
#include <stdlib.h>

int main () {
	int a[3][2] = { (0, 1), (2, 3), (4, 5) };
	int* p;
	p = a[0];
	printf("%d\n",p[0]); //1 p[0] = *(p+0)  要注意逗号表达式的使用方式,始终取的是逗号后面的值.
    system ("pause");
    return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//问题5:
#include <stdio.h>
#include <stdlib.h>

int main () {
	int a[5][5];
	int(*p)[4];
	p = a;
	printf("%p,%d\n", &p[4][2] - &p[4][2], &p[4][2] - &p[4][2]);
    system ("pause");
    return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//问题6：

#include <stdio.h>
#include <stdlib.h>

int main () {
	int aa[2][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	int* ptr1 = (int*)(&aa + 1); //&aa得到一个数组指针,+1跳过整个数组 指向数字9的后面
	int* ptr2 = (int*)(*(aa + 1)); //aa + 1 首元素的地址+1,由于是两行5列因此指向6的位置.
	printf("%d,%d\n",*(ptr1-1),*(ptr2-1)); // *(ptr1-1) 得到一个10 *(ptr2-1) 得到5
    system ("pause");
    return 0;
}
问题7:
#include <stdio.h>
#include <stdlib.h>

int main () {
	char* a[] = { "work", "at", "alibaba" };
	char** pa = a;
	pa++;
	printf("%s\n",*pa); // at 
    system ("pause");
    return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//问题8:
#include <stdio.h>
#include <stdlib.h>

int main () {
	char* c[] = { "ENTER", "NEW", "POINT", "FIRST" };
	char** cp[] = { c + 3, c + 2, c + 1, c };
	char*** cpp = cp;

   //cpp的值都要承接到下面的去的
	printf("%s\n",**++cpp);
	//printf("%s\n",*--*++cpp+3);
	//printf("%s\n",*cpp[-2]+3);
	//printf("%s\n",cpp[-1][-1]+1);

    system ("pause");
    return 0;
}
















