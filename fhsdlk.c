//指针进阶常考例题:
//结合指针 ,数组 常考字符长度字符串长度的举例
#include <stdio.h>
#include <stdlib.h>

int main() {
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//第一组
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	int arr[4] = { 1, 2, 3, 4 };
	printf("%d\n", sizeof(arr)); // 16 sizeof 求得是字符数组所占字节的大小.
	printf("%d\n", sizeof(arr + 1));// 4 数组名参与运算会隐式转为指针,指向首元素的地址(int*) 指针在32位操作系统下占4个字节,在64位操作系统下占8个字节
	printf("%d\n", sizeof(arr + 0));//4 同上 数组名参与运算会隐式转为指针
	printf("%d\n", sizeof(*arr)); //4 arr等于已经给隐式转为指针,指向了首元素的地址,然后再解引用(*arr),就得到了整数1,一个int在32位操作系统用下占4个字节
	printf("%d\n", sizeof(arr[1])); // 4 指向整型元素2
	printf("%d\n", sizeof(&arr)); // 4 &arr得到一个数组指针,int(*)[],数组指针也是一个指针指向一个长度为4的整型数组.
	printf("%d\n", sizeof(&arr + 1)); //4 同上仍然是一个数组指针,
	printf("%d\n", sizeof(&arr[0])); //4 int* 
	printf("%d\n", sizeof(&arr[0] + 1));// 4 同上
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//第二组
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	char arr[] = { 'a', 'b', 'c', 'd', 'e', 'f' };
	printf("%d\n", sizeof(arr)); // 6 求字符数组所占的字节大小,字符数组最后没有\0因此在计算的时候不用求\0的长度
	printf("%d\n", sizeof(arr + 0)); // 4 会隐式转化为指针指向首元素的地址
	printf("%d\n", sizeof(*arr));//arr直接打印会隐式转为指针,指向首元素的地址,然后在进行解引用得到一个字符'a',一个字符在32位操作系统下占一个字节
	printf("%d\n", sizeof(arr[1]));//根据下标直接指向的是字符'b'
	printf("%d\n", sizeof(&arr));// 4 &arr得到一个数组指针,数组指针仍然是指针载2位操作系统下占4个字节的大小
	printf("%d\n", sizeof(&arr)); //4  数组指针+1仍然是数组指针 ,指针占4个字节
	printf("%d\n", sizeof(&arr[0] + 1));//&arr[0]得到的是一个char* ,char*+1仍然是一个char*类型,占4个字节的大小
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//第三组
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	char arr[] = { 'a', 'b', 'c', 'd', 'e', 'f' };
	printf("%d\n", strlen(arr)); // 未定义行为 strlen求得是字符串的长度(找到\0位置结束即可),对于字符数组来说没有\0,
	printf("%d\n", strlen(arr + 0));// 未定义行为 找不到\0的位置
	printf("%d\n", strlen(*arr));// 未定义类型 *char 得到一个char的类型与strlen所需要的类型不tong 
	printf("%d\n", strlen(arr[1])); //arr[1] 得到字符'b',和所需要的 类型不符合
	printf("%d\n", strlen(&arr)); //得到的char(*)[] 和strlen所需要的类型不符合
	printf("%d\n", strlen(&arr + 1)); //数组指针+1仍然是数组指针
	printf("%d\n", strlen(&arr[0] + 1)); //没有找到\0
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//第四组
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	char arr[] = "abcdef";
	printf("%d\n", sizeof(arr)); // 7 
	printf("%d\n", sizeof(arr + 0)); // 1数组名隐式转为指针,指向首元素的地址
	printf("%d\n", sizeof(*arr));//1 arr 得到首元素的地址,再取*得到字符'a'
	printf("%d\n", sizeof(arr[1])); //1 指向字符'b' 
	printf("%d\n", sizeof(&arr));//4 数组指针占4个字节
	printf("%d\n", sizeof(&arr + 1)); //4 数组指针+1得到还是数组指针
	printf("%d\n", sizeof(&arr[0] + 1));// 4 &arr[0]+1)得到char* 类型
	printf("%d\n", strlen(arr)); // 6 对于strlen函数求字符串的长度遇到\0就结束
	printf("%d\n", strlen(arr + 1));// arr+1 隐式转为指针,指向'b'的地址,然后从字符'b'往后开始寻找找到\0就可以了
	printf("%d\n", strlen(*arr)); // *arr 的类型为char和strlen所需要的类型不一样
	printf("%d\n", strlen(arr[1])); //同上
	printf("%d\n", strlen(&arr));//数组指针和char*不是同一个类型
	printf("%d\n", strlen(&arr + 1)); // 数组指针+1跳过整个数组
	printf("%d\n", strlen(&arr[0] + 1)); //5 &arr[0] + 1指向'b'地址,
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//第5组
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	char* p = "abcdef";
	printf("%d\n", sizeof(p)); //4 p本身就是一个char* ,指针占4个字节
	printf("%d\n", sizeof(p + 1));//4  p+1 p本身就是一个char*,p+1
	printf("%d\n", sizeof(p[1]));//1 p[1] =*(p+1) 得到一个char 类型
	printf("%d\n", sizeof(*p));// 1
	printf("%d\n", sizeof(&p)); //4 p 本身是一个char*, &p得到一个 char**
	printf("%d\n", sizeof(&p + 1)); //4 二级指针+1仍然是二级指针
	printf("%d\n", sizeof(&p[0] + 1));//4  &p[0] 得到char* 
	printf("%d\n", strlen(p)); //6 p本身就是一个char*
	printf("%d\n", strlen(p + 1));//5 从'b'往后开始查找\0
	printf("%d\n", strlen(*p)); //*p得到的是char类型而strlen需要char* 类型
	printf("%d\n", strlen(p[1])); //*(p+1) 得到一个字符'b'和strlen所需要的类型不符合,因此是未定义行为
	printf("%d\n", strlen(&p)); //&p 得到char**
	printf("%d\n", strlen(&p[0] + 1));//5 p[0] 代表对应字符a &p[0]代表取a的地址,&p[0]+1 代表取'b'的地址,对于strlen函数而言,目的就是寻找\0的位置,找到就结束
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//第六组
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	int a[3][4] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };
	printf("%d\n", sizeof(a)); // sizeof求得是数组中所占字节的大小
	printf("%d\n", sizeof(a[0][0])); //一个int 在32位操作系统下占4个字节
	printf("%d\n", sizeof(a[0]));//16 a[3][4] 代表的是长度为3的一维数组,每个元素又是长度为4(int[0])的一维数组  
	/*a[0] 1 2 3 4
	a[1] 5 6 7 8
	a[2] 9 10 11 12*/
	printf("%d\n", sizeof(a[0] + 1)); //  长度为4  类型为int*
	printf("%d\n", sizeof(*(a[0] + 1)));// 4 int* 在进行解引用 
	printf("%d\n", (*(a[0] + 1))); // 2  a[0]类似于指向a[0]哪一行元素的首地址
	printf("%d\n", sizeof(&a[0] + 1)); // 4  i得到的是一个数组指针nt(*)[4]
	printf("%d\n", sizeof(*(&a[0] + 1))); //16 数组指针解引用得到整个数组 
	printf("%d\n", sizeof(*a)); // 16
	printf("%d\n", sizeof(*(a + 0))); //16 
	printf("%d\n", sizeof(*a[0])); //4
	printf("%d\n", sizeof(a[3]));// 16  sizeof 是一种运算符,是在编译期的时候完成,而出现内存访问越界,是在运行的时候完成的,因此不存在越界的行为
	printf("%d\n", sizeof(a[100])); //16

	system("pause");
	return 0;
}
//1.编译期: 将.c文件变成.exe文件,VS分析代码的逻辑,完成代码的翻译
//2.运行时: 双击.exe ,操作系统加载可执行程序,并且完成其中的逻辑
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//关于 const 与指针结合起来的使用:
#include <stdio.h>
#include <stdlib.h>

int main() {
	int num = 10;
	int num2 = 20;
	const int* p = &num;
	//*p = 20; // 限制修改指针所对应的内存   1
	//p=&num2; // 限制修改指针指针的指向

	system("pause");
	return 0;
}

//1.const int* p:  限制修改指针所对应的内存 1
//2.int const* p;  限制修改指针所对应的内存 1
//3.int* const p;  限制修改指针的指向  2
//总结:c语言中关于字符串和字符串数组的区别 :
1.字符串是字符数组的特殊情况 字符串是以\0为结尾的
strlen函数求得是字符串的长度(即找到\0)
sizeof求得是所占的字节大小
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//指针进阶提升例题整理:
//问题1:
#include <stdio.h>
#include <stdlib.h>

int main() {
	int a[5] = { 1, 2, 3, 4, 5 };
	int* ptr = (int*)(&a + 1); //&a得到一个数组指针,数组指针+1 跳过整个数组(&a + 1)  int(*)[5] 然后在强转为(int*)
	printf("%d,%d\n", *(a + 1), *(ptr - 1)); //2,5


	system("pause");
	return 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//问题2:
#include <stdio.h>
#include <stdlib.h>

struct Test{

	int Num;
	char* pcName;
	char cha[2];
	short Sba[4];

};

int main() {
	struct Test* p = (struct Test*)0x100000;
	//printf("%p\n",p+0x1); //已知结构体占20个字节(十六进制对应14) 等于结构体跳过一个元素 100014
	//结构体占20个字节的大小 %p 代表打印一个指针变量的内容(地址),习惯上用16进制表示.
	printf("%d\n", (unsigned long)p + 0x1); //100001 p本来是一个结构体指针,但是(unsigned long)p等于将p强转为长整数型,整数+1只是单纯的+1;
	//(unsigned long)p p+1,等于整数+1,不会存在指针的类型.
	printf("%d\n", (unsigned int*)p + 0x1); // 0x100004 p本来是一个结构体指针,但是(unsigned int*)p等于将p强转为无符号的指针类型p+1类似于地址+4
	//对于(unsigned int*)p 假如P+1,(类似于指针+1)等于跳过一个元素(unsigned int 占4个字节的大小)
	system("pause");
	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//问题3:
#include <stdio.h>
#include <stdlib.h>

int main() {
	int a[4] = { 1, 2, 3, 4 };
	int* ptr1 = (int*)(&a + 1);
	int* ptr2 = (int*)((int)a + 1);
	printf("%x,%x\n", ptr1[-1], *ptr2);

	system("pause");
	return 0;
}
//1  2   3   4的十六进制数对应的  |01  00  00 00 |02 00 00 00 |03 00 00 00 | 04 00 00 00 |

&a得到一个数组指针(类型int(*)[4]), 然后又通过int*进行强转
(int)a意思是将a强转成整形, (int)a + 1等于首元素的地址加一个整数, 从 + 1的位置开始往后数.   (这块一定分清楚指针 + 1和整数 + 1的区别)
*ptr2 意思是 + 1的位置开始往后数, 找到4个字节大小的位置即可.
///
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//问题4:
#include <stdio.h>
#include <stdlib.h>

int main() {
	int a[3][2] = { (0, 1), (2, 3), (4, 5) };
	int* p;
	p = a[0];
	printf("%d\n", p[0]); //1 p[0] = *(p+0)  要注意逗号表达式的使用方式,始终取的是逗号后面的值.
	system("pause");
	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//问题5:
#include <stdio.h>
#include <stdlib.h>

int main() {
	int a[5][5];
	int(*p)[4];
	p = a;
	printf("%p,%d\n", &p[4][2] - &p[4][2], &p[4][2] - &p[4][2]);
	system("pause");
	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//问题6：

#include <stdio.h>
#include <stdlib.h>

int main() {
	int aa[2][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	int* ptr1 = (int*)(&aa + 1); //&aa得到一个数组指针,+1跳过整个数组 指向数字9的后面
	int* ptr2 = (int*)(*(aa + 1)); //aa + 1 首元素的地址+1,由于是两行5列因此指向6的位置.
	printf("%d,%d\n", *(ptr1 - 1), *(ptr2 - 1)); // *(ptr1-1) 得到一个10 *(ptr2-1) 得到5
	system("pause");
	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//问题7:
#include <stdio.h>
#include <stdlib.h>

int main() {
	char* a[] = { "work", "at", "alibaba" };
	char** pa = a;
	pa++;
	printf("%s\n", *pa); // at 
	system("pause");
	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//问题8:
#include <stdio.h>
#include <stdlib.h>

int main() {
	char* c[] = { "ENTER", "NEW", "POINT", "FIRST" };
	char** cp[] = { c + 3, c + 2, c + 1, c };
	char*** cpp = cp;

	//cpp的值都要承接到下面的去的
	printf("%s\n", **++cpp);
	//printf("%s\n",*--*++cpp+3);
	//printf("%s\n",*cpp[-2]+3);
	//printf("%s\n",cpp[-1][-1]+1);

	system("pause");
	return 0;
}
















