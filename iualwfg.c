//***********************青蛙跳台阶算法**************************
//一.关于问题的描述:
//一只青蛙可以一次跳上1级台阶,也可以跳上2级台阶.求该青蛙跳上一个n级的台阶总数一共需要多少种跳法?
//
//
//思路:先要想清楚特殊情况的存在,当n分别等于0,1,时,计算f(n)各自有几种跳法?n代表跳的台阶数
//f(0)=0,f(1)=1,
//当n等于2时,青蛙可以一次跳一级或者一次直接2级,因此f(2)=2
//当n等于3时,青蛙第一跳有两种情况:跳一级台阶或者跳两级台阶,假如跳一级台阶,那么剩下的两极台阶就是f(2),
//                                                     假如跳2级台阶,那么剩下的一级台阶就是f(1),
//                                                    f(3)=f(1)+f(2)
//也可以这样理解:直接看一共n=3时,青蛙一共跳完有几种方法 ,假如第一次跳一级台阶,后面也都跳一级.(跳法1)
//                                                    假如第一次跳一级台阶,后面跳2级.(跳法2)
//                                                    假如第一次跳两级台阶,后面跳一级.(跳法3) 
//综上:当n=3时,一共有3种跳法.f(3)=3=f(1)+f(2)
//n=4时,将各种情况依次列出来,其结果恰好等于f(2)+f(3)
//依次类推:f(n)=f(n-1)+f(n-2)
//递归实现:
//#define _CRT_SECURE_NO_WARNINGS
//#include <stdio.h>
//#include <stdlib.h>
//#include <string.h>
//
//int Func(int n){
//	if (n == 0){
//		return 0;
//	}
//	if (n == 1){
//		return 1 ;
//	}
//	if (n == 2){
//		return 2;
//	}
//	if (n>=3){
//		return Func(n-1) + Func(n-2);
//	}
//}
//
//int main(){
//	int n = 0;
//	printf("请输入青蛙一共要跳的台阶总数: \n");
//	scanf("%d",&n);
//	printf("%d\n", Func(n));
//	system("pause");
//	return 0;
//}
//***********************************************************************************************
//递归的两个必要条件:1.存在限制条件,当满足这个递归条件的时候,递归将不再继续执行下去.
//                  2.每次递归调用之后,越来越接近限制条件
//迭代实现:
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int Func(int n){
   // i代表几级台阶总数 n代表一共的台阶总数
	int last1 = 1;
	int last2 = 2;
	int cur;

	int i;
	if (n == 0){
		return 0;
	}
	if (n == 1){
		return 1 ;
	}
	if (n == 2){
		return 2;
	}
	for (i = 3;i<= n;i++){
		cur = last1 + last2;
		last1 = last2;
		last2 = cur;
	}
	return  cur ;
}

int main(){
	int n ;
	printf("请输入青蛙一共要跳的台阶总数: \n");
	scanf("%d",&n);
	printf("%d\n", Func(n));
	system("pause");
	return 0;
}
////迭代法相比递归法效率要高,避免了重复计算

















