//***********C进阶**********
//1.c语言中变量的类型:
//1.整数类型(int char short )
//2.浮点数型(float double)
//3.指针类型(int* char*)
//4.结构体(自定制类型)
//*********************************************************
//1.整型在内存中的存储
//#include <stdio.h>
//#include <stdlib.h>
//
//int main(){
//	int num = 10;
//	int* p = &num;
//	printf("%p\n",p);
//	system("pause");
//	return 0;
//}

//****************************************************************************
//调试器显示: 0x008FFD44   0a 00 00 00(与前面对应地址大小依次递增)
//地址:  低地址(左)          高地址(右)         

//*********字节序问题:***************
//小端字节序: (0a 00 00 00) 数字的低位存到内存的低地址上   小(小端字节序)    小(数字低的)    小(低地址上)
//大端字节序: (00 00 00 0a) 数字的低位存在内存的高地址上 大端字节序的方式比较像日常数学一样 (千位 百位 十位 个位)
//	一台机器大端或者小端取决于CPU
//
//#include <stdio.h>
//#include <stdlib.h>
//
////返回值是1,证明是小端字节序.返回值是0,证明是大端字节序
//int IsLittleEnd(){
//	int num = 0x11113344;
//	int* p = &num;
//	char* p2 = (char*)p;
//	if (*p2 == 0x44){
//		return 1;
//	}
//	return 0;
//}
//int main(){
//
//	printf("%d\n", IsLittleEnd());
//	system("pause");
//	return 0;
//}
//**指针变量涉及的信息:
//1.内存对应的地址是那个地址(指针变量中存的数字决定的)
//2.这个内存对应的大小(指针类型体现的)int* 占4个字节 char*占一个字节
//**指针的解引用
//#include <stdio.h>
//#include <stdio.h>
//
//int main(){
//	int num = 10;
//	//此处的*和int是一个整体共同构成(int*)
//		int* p = &num;
//	//此处的*是解引用, 根据指针变量中存储的地址找到对应内存中的值.
//	printf("%d\n", *p);
//
//	system("pause");
//	return 0;
//}
//********************************************************************************************
//**************负的整数在内存中的存储***********
//1.int 既能表示正数,也能表示负数(最高位是符号位,1表示)
//2.unsigned int只能表示正数(无符号位)
//正数:原码=反码=补码
//负数:原码取反加1=补码  同样  补码取反加1等于原码

//举例:
//#include <stdio.h>
//#include <stdlib.h>
//
//
//int main(){
//	int i = 2;
//	int j = -1;
//	int ret = i + j;
//	printf("%d\n",ret);
//
//	system("pause");
//	return 0;
//}

//计算机中存储负数:以补码的形式为存储,补码进行存储使计算机的硬件设备实现起来比较方便.
//对于负数来说,需要把原码转成补码在存储.
//通过补码的形式统一能把二进制的加减法统一成加法计算.CPU实现加法,有相应的加法器.
//对于有二进制进行计算时,如果有溢出就将溢出的部分舍掉.
//例1.
//#include <stdio.h>
//#include <stdlib.h>
//
//int main(){
//
//	char a = -1;
//	signed char b = -1;
//	unsigned char c = -1;
//   //%d是打印的是十进制有符号的整数
//	printf("a=%d b=%d c=%d\n",a,b,c);
//
//	system("pause");
//	return 0;
//}
//*****************************************************************************************************
// a = -1;
//首先%d是打印的是十进制有符号的整数.因此a会被隐式转化为int,在这个转化过程成,高位的三个字节也需要填充,按照符号位来填充(看a 的最高位是0还是1)1代表正数,0代表负数
//计算机中负数以补码的形式存在 char(1个字节8个bite 位) :-1的补码是 1111 11111 
//int(4个字节32个bite位)当char 到int时 其余位置补符号位

//b=-1;
//具体步骤和a相同
//c=255
//-1 的补码1111 1111 因为是unsigned int (无符号位) 8个1 理解成正数因此char到int时最高位全部补 0
//0000 0000 0000 0000 0000 0000 1111 1111 十进制是255   %d打印的始终都是十进制有符号的正数.
//**总结:
//1.明确%d打印的始终都是十进制有符号的正数.
//2.负数在计算机中的存储始终都是以补码的形式存储.
//3.范围小的字节往大的字节转化时,一定要将其他的位置拿符号位进行填充
//例2.
//#include <stdio.h>
//#include <stdlib.h>
//
//int main(){
//	char a = -128;
//	//打印一个无符号的十进制的整数
//	printf("%u\n",a);
//
//
//
//	system("pause");
//	return 0;
//}
//4294967168************************************************************************************************
//步骤:
//-128 原码:1000 0000 0000 0000 00000 0000 1000 0000
//-128 反码:1111 1111 1111 1111 1111 1111 0111 1111
//-128 补码:1111 1111 1111 1111 1111 1111 1000 0000
//负数在计算器中以补码的形式存在.
//因为是char 所以截取一个字节的长短 1000 0000 然后因为打印一个无符号的十进制的整数
//所以先转换成int 最高位补符号位1111 1111 1111 1111 1000 0000 int 再转为 unsigned  int(题目打印的是%u)因此最高位不在是符号位
//从而打印一个很大的整数

//总结:char 的范围是0~255  -128-127 short 的范围是0~65536 -32768-32767 int 的范围是42亿9千万  -21亿-21亿
//char =-128刚好在char 本身的大小范围内
//过程: char 到int  再到unsigned int 切记负数在计算器的存储是以它的补码形式存储的

//例3.
#include <stdio.h>
#include <stdlib.h>

int main(){
	char a = 128;
	printf("%u\n",a);

	system("pause");
	return 0;
}
//4294967168
//************************************************************************************************************
//整型128二进制表示: 0000 0000 0000 0000 0000 0000 1000 0000
//当char 等于128时 发生了截断(char 是一个字节8个bite位) 截取了1000 0000
//char型 1000 0000(1 阴差阳错成为了符号位)到int型 1111 1111 1111 1111 1111 1111 1000 0000
//又因为%u代表打印的是十进制无符号整型.因此1111 1111 1111 1111 1111 1111 1000 0000变为了unsigned int 最高位不再是符号位
// 打印的数字变成了一个很大的正数






































































































































