//指针进阶的举例:


#include <stdio.h>
#include <stdlib.h>

int main () {
	char arr[] = { 'a', 'b', 'c', 'd', 'e', 'f' };
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	第3组
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	printf("%d\n",strlen(arr)); // 未定义行为 strlen求得是字符串的长度(找到\0位置结束即可),对于字符数组来说没有\0,
	printf("%d\n", strlen(arr+0));// 未定义行为 找不到\0的位置
	printf("%d\n", strlen(*arr));// 未定义类型 *char 得到一个char的类型与strlen所需要的类型不tong 
     printf("%d\n", strlen(arr[1])); //arr[1] 得到字符'b',和所需要的 类型不符合
	printf("%d\n", strlen(&arr)); //得到的char(*)[] 和strlen所需要的类型不符合
	printf("%d\n", strlen(&arr+1)); //数组指针+1仍然是数组指针

	printf("%d\n", strlen(&arr[0] + 1)); //没有找到\0
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	第四组
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	char arr[] = "abcdef";
	printf("%d\n",sizeof(arr)); // 7 

	printf("%d\n", sizeof(arr+0)); // 1数组名隐式转为指针,指向首元素的地址
	printf("%d\n", sizeof(*arr));//1 arr 得到首元素的地址,再取*得到字符'a'
	printf("%d\n", sizeof(arr[1])); //1 指向字符'b' 

	printf("%d\n", sizeof(&arr));//4 数组指针占4个字节
	printf("%d\n", sizeof(&arr+1)); //4 数组指针+1得到还是数组指针
	printf("%d\n", sizeof(&arr[0]+1));// 4 &arr[0]+1)得到char* 类型


	printf("%d\n",strlen(arr)); // 6 对于strlen函数求字符串的长度遇到\0就结束
	printf("%d\n", strlen(arr+1));// arr+1 隐式转为指针,指向'b'的地址,然后从字符'b'往后开始寻找找到\0就可以了
	printf("%d\n", strlen(*arr)); // *arr 的类型为char和strlen所需要的类型不一样
	printf("%d\n", strlen(arr[1])); //同上
	printf("%d\n", strlen(&arr));//数组指针和char*不是同一个类型
	printf("%d\n", strlen(&arr+1)); // 数组指针+1跳过整个数组
	printf("%d\n", strlen(&arr[0] + 1)); //5 &arr[0] + 1指向'b'地址,
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	第5组
   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	char* p = "abcdef";
	printf("%d\n",sizeof(p)); //4 p本身就是一个char* ,指针占4个字节
	printf("%d\n", sizeof(p+1));//4  p+1 p本身就是一个char*,p+1
	printf("%d\n", sizeof(p[1]));//1 p[1] =*(p+1) 得到一个char 类型
	printf("%d\n", sizeof(*p));// 1
	printf("%d\n", sizeof(&p)); //4 p 本身是一个char*, &p得到一个 char**
	printf("%d\n", sizeof(&p+1)); //4 二级指针+1仍然是二级指针
	printf("%d\n", sizeof(&p[0] + 1));//4  &p[0] 得到char* 

	printf("%d\n",strlen(p)); //6 p本身就是一个char*
	printf("%d\n", strlen(p+1));//5 从'b'往后开始查找\0
	printf("%d\n", strlen(*p)); //*p得到的是char类型而strlen需要char* 类型
	printf("%d\n", strlen(p[1])); //*(p+1) 得到一个字符'b'和strlen所需要的类型不符合,因此是未定义行为
	printf("%d\n", strlen(&p)); //&p 得到char**
	printf("%d\n", strlen(&p[0]+1));//5 p[0] 代表对应字符a &p[0]代表取a的地址,&p[0]+1 代表取'b'的地址,对于strlen函数而言,目的就是寻找\0的位置,找到就结束
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	第6组
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	int a[3][4] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };
	printf("%d\n",sizeof(a)); // sizeof求得是数组中所占字节的大小
	printf("%d\n", sizeof(a[0][0])); //一个int 在32位操作系统下占4个字节
	printf("%d\n", sizeof(a[0]));//16 a[3][4] 代表的是长度为3的一维数组,每个元素又是长度为4(int[0])的一维数组  
	                                a[0] 1 2 3 4
	                                a[1] 5 6 7 8 
	                                a[2] 9 10 11 12 
	printf("%d\n", sizeof(a[0]+1)); //  长度为4  类型为int*
	printf("%d\n", sizeof(*(a[0] + 1)));// 4 int* 在进行解引用 
	printf("%d\n", (*(a[0] + 1))); // 2  a[0]类似于指向a[0]哪一行元素的首地址
	printf("%d\n", sizeof(&a[0] + 1)); // 4  i得到的是一个数组指针nt(*)[4]
	printf("%d\n", sizeof(*(&a[0] + 1))); //16 数组指针解引用得到整个数组 
	printf("%d\n", sizeof(*a)); // 16
	printf("%d\n", sizeof(*(a+0))); //16 
	printf("%d\n", sizeof(*a[0])); //4

	printf("%d\n", sizeof(a[3]));// 16  sizeof 是一种运算符,是在编译期的时候完成,而出现内存访问越界,是在运行的时候完成的,因此不存在越界的行为
	printf("%d\n",sizeof(a[100])); //16

    system ("pause");
    return 0;
}
//1.编译期: 将.c文件变成.exe文件,VS分析代码的逻辑,完成代码的翻译
//2.运行时: 双击.exe ,操作系统加载可执行程序,并且完成其中的逻辑
//关于 const 与指针结合起来的使用:
#include <stdio.h>
#include <stdlib.h>

int main () {
	int num = 10;
	int num2 = 20;
	const int* p = &num;
	//*p = 20; // 限制修改指针所对应的内存   1
	//p=&num2; // 限制修改指针指针的指向

    system ("pause");
    return 0;
}


1.const int* p:  限制修改指针所对应的内存 1
2.int const* p;  限制修改指针所对应的内存 1
3.int* const p;  限制修改指针的指向  2  
























