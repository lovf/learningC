//******************整数在内存中的存储:

//1.大小端字节序的断定:

#include <stdio.h>
#include <stdlib.h>

int IsLittleEnd() {
	int a = 0x11223344;
	int* p1 = &a;
	char* p2 = (char*)&a;
	if (*p2 == 0x44) {
		return 1;
	}
	return 0;
}
int main() {
	printf("%d\n", IsLittleEnd());
	system("pause");
	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 负整数在内存的存储: 负数以补码的形式存储
// 2.针对不同类型,判定具体的存储的方式
 //问题1:

#include <stdio.h>
#include <stdlib.h>

int main() {
	char a = -1;
	signed char b = -1;
	unsigned char c = -1;
	printf("a=%d,b=%d,c=%d\n", a, b, c);
	system("pause");
	return 0;
}


%d 表示打印的是一个有符号的十进制的整数.

1 > 针对char a = -1 求解过程:**
 第一步:
先将a = -1的二进制画出来 int占4个字节32个bit位
a = -1;  -1原码:1000 0000 0000 0000 0000 0000 0000 0001
- 1反码 : 1111 1111 1111 1111 1111 1111 1111 1110
- 1补码 : 1111 1111 1111 1111 1111 1111 1111 1111
- 1在二进制中以补码的形式存储 : 1111 1111 1111 1111 1111 1111 1111 1111

 第二步:
因为a的前面是char类型 1个字节占8个bit位
char a = -1的二进制位 : 1111 1111
 第三步:
因为%d打印的是一个十进制有符号的整数(int)
1111 1111 1111 1111 1111 1111 1111 1111 (最高位补充的符号位)因为char只有8个bit位, 而int占32个bit位, 因此需要补充符号位

2 > 针对signed char b = -1求解过程:**
代表的是有符号的类型, 因此求解过程和char a = -1完全一样;
#### 第一步:
先将a = -1的二进制画出来 int占4个字节32个bit位
a = -1;  -1原码:1000 0000 0000 0000 0000 0000 0000 0001
- 1反码 : 1111 1111 1111 1111 1111 1111 1111 1110
- 1补码 : 1111 1111 1111 1111 1111 1111 1111 1111
 第二步:
因为a的前面是char类型 1个字节占8个bit位
char a = -1的二进制位 : 1111 1111
 第三步:
因为%d打印的是一个十进制有符号的整数(int)
1111 1111 1111 1111 1111 1111 1111 1111 (最高位补充的符号位)因为char只有8个bit位, 而int占32个bit位, 因此需要补充符号位

3 > 针对unsigned char c = -1的求解过程:**
 第一步:
先将a = -1的二进制画出来 int占4个字节32个bit位
a = -1;  -1原码:1000 0000 0000 0000 0000 0000 0000 0001
- 1反码 : 1111 1111 1111 1111 1111 1111 1111 1110
- 1补码 : 1111 1111 1111 1111 1111 1111 1111 1111
 第二步:
因为a的前面是char类型 1个字节占8个bit位
unsigned char a = -1的二进制位 : 1111 1111
 第三步:
因为%d打印的是一个十进制有符号的整数(int)
0000 0000 0000 0000 0000 0000 1111 1111 (最高位补充的符号位)因为char只有8个bit位, 而int占32个bit位, 因此需要补充符号位
unsigned char 代表无符号整数, 因此最高位补充的是0.
///
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//问题2:
#include <stdio.h>
#include <stdlib.h>

int main() {
	char a = -128;
	printf("%u\n", a);

	system("pause");
	return 0;
}

 第一步:
a = -128的二进制 : -128原码 : 1000 0000 0000 0000 0000 0000 1000 0000
- 128反码 : 1111 1111 1111 1111 1111 1111 0111 1111
- 128补码 : 1111 1111 1111 1111 1111 1111 1000 0000

 第二步: 
对于char a来说对应的二进制占8个bit位, 因此从第一步 - 128补码中截取8个bit位 1000 0000
 第三步:
%u打印的是十进制无符号的整数(int)  1111 1111 1111 1111 1111 1111 1000 0000(最高位补符号位)但是此时最高位的1不再是符号位, 最终导致打印结果是一个很大的整数
int ->char->unsigned int
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
问题3:

#include <stdio.h>
#include <stdlib.h>

int main() {
	char a = 128;
	printf("%u\n", a);

	system("pause");
	return 0;
}

**求解过程:**
%u代表打印无符号的十进制整数
 第一步:
a = -128的二进制 : -128原码 : 1000 0000 0000 0000 0000 0000 1000 0000
- 128反码 : 1111 1111 1111 1111 1111 1111 0111 1111
- 128补码 : 1111 1111 1111 1111 1111 1111 1000 0000
 第二步:
char a = 128 截取最后8个bit位 1000 0000 (此时最高位1代表的就是符号位, 因为假如不是符号位, 对于char类型的范围是 - 128~127, 没有 + 128)
 第三步:
%u打印的是十进制无符号的整数(int)  1111 1111 1111 1111 1111 1111 1000 0000(最高位补符号位)但是此时最高位的1不再是符号位, 最终导致打印结果是一个很大的整数

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

























