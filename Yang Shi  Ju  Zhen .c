
//杨氏矩阵（一个二维数组，数组的每行从左到右是递增的，每列从上到下是递增的）在这样的数组中查找一个数字是否存在。
//题目要求:时间复杂度度不能大于O(N)
//所以判断次数必须小于遍历一次数组次数。依次遍历的方法就行不通(因此数组遍历的方法就行不通)


// 解题思路：
// 1> 首定根据矩阵定义一个数组，并初始化为上述所示；
// 2> 为了满足时间复杂度小于O(N)所以只能有一个循环，所以通过遍历数组与你输入的值比较就行不通了，
//因此我们采用while循环，根据杨氏矩阵的性质： 数组的每行  从左到右是递增的，列从上到下是递增的，
//从数组的右上角开始判断，若当前元素大于要查找的数字，则跳过当前列查询上一列，若当前元素小于要查找的数，则跳过当前行查找下一行，直至找到或者找不到。
// 相等时返回下标，不等返回没找到；                  
//eg：
//此处使用数组arr[3][3] = { 1，2，3，4，5，6，7，8，9 }；
//1 2 3
//4 5 6
//7 8 9
//在数组中朝查找5，首先判断3<5, 则查找范围就变成了
//4 5 6
//7 8 9
//再判断6>5, 则查找范围又变为了
//4 5
//7 8
//这时候再判断5 = 5
//则找到
//源代码 :
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include <string.h>

int  find(int arr[3][3], int *row, int *col, int toFind){

	//等于是最先从右上角开始查找
	int x = 0;
	int y = *col - 1;

	while (x < *row && y > 0)//判断条件
	{
		if (arr[x][y] == toFind)//找到
		{
			*row = x;
			*col = y;
			return  *row, *col;
		}
		else if (arr[x][y] < toFind)
		{
			x++;//变换行
		}
		else
		{
			y--;//变换列
		}
	}
	*row = -1;
	*col = -1;
}
int main(){
	int arr[3][3] = {
		{ 1, 2, 3 },
		{ 4, 5, 6 },
		{ 7, 8, 9 },
	};

	int x = 3;
	int y = 3;

	int *row = &x;
	int *col = &y;

	int toFind;
	printf("请输入要查找的数字: \n");

	scanf("%d", &toFind);
	find(arr, row, col, toFind);

	if (*row == -1 && *col == -1){
		printf("没找到\n");
	}
	else{
		printf("查找到这个数是: %d 下标是: %d %d\n", toFind ,*row, *col);
	}
	system("pause");
	return 0;
}
//****************************************************************************************

