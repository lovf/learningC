//*********************************************************
//对于正数而言:原码=反码=补码 对于负数而言: 原码取反加1等于补码 (负数在计算机中的存储是以补码的形式存储的) 补码取反加1等于原码 
//char 类型的范围:0~255. -128~127 short 类型的范围:0~65535 -32768~32767 int 类型的范围:0~42亿9千万.-21亿~21亿
//例4.
//#include <stdio.h>
//#include <stdlib.h>
//
//int main(){
//	int i = -20;
//	unsigned int j = 10;
//
//	printf("%d\n",i+j);
//
//	system("pause");
//	return 0;
//}
////%d打印的是一个有符号的十进制的整数 
////对于i+j(存在隐式类型的转化)必须要将两个变量化为同一个类型. 转化规则:范围小的往范围大的类型隐式转化
////范围从上到下依次递增:
////long double
////double
////float 
////unsigned long int 
////long int 
////unsigned int 
////int
////具体解题步骤:-20 原码 1000 0000 0000 0000 0000 0000 0001 0100
////            -20 反码 1111 1111 1111 1111 1111 1111 1110 1011
////            -20 补码 1111 1111 1111 1111 1111 1111 1110 1100
//
////转为 unsigned int  1111 1111 1111 1111 1111 1111 1110 1100 (最高位不再是符号位)
////10 原码=反码=补码  0000 0000 0000 0000 0000 0000 0000 1010
////二者相加           1111 1111 1111 1111 1111 1111 1111 0110
////得到unsigned int 然后再把unsigned int转化为int  1111 1111 1111 1111 1111 1111 1111 0110(最高位代表符号位)
////具体得到的这个数字多大,最高位是1 因此这个数字是负数 将这个负数取反加1 就得到结果 1000 000 000 0000 0000 0000 0000 1001 对应十进制是-10
//*************************************************************************************************************

//例5.
//#include <stdio.h>
//#include <stdlib.h>
//
//int main(){
//	unsigned  int i;
//	for (i = 9; i >= 0;i--){
//		printf("%u\n",i);
//	}
//
//	system("pause");
//	return 0;
//}
//i-- = i-=1 = i=i-1
//当i=0时,执行 i=i-1这一过程0-1 =0+(-1)
//-1 原码 1000 0000 0000 0000 0000 0000 0000 0001
//-1 反码 1111 1111 1111 1111 1111 1111 1111 1110
//-1 补码 1111 1111 1111 1111 1111 1111 1111 1111
//因为是一个unsigned int 类型 最高位不再是符号位 转变成一个很大的正数  故该题打印的值都是很大的正数
//**************************************************************************************************************
//例6.
//#include <stdio.h>
//#include <stdlib.h>
//
//int main(){
//
//	char a[1000];
//	int i;
//	for (int i = 0; i < 1000;i++){
//		a[i] = -1 - i;
//	}
//	printf("%d\n",strlen(a));
//
//	system("pause");
//	return 0;
//}
// 本题要明确 strlen计算字符串的长度 意思就是a[i]的结果是0 (字符类型)
//-1 原码 1000 0000 0000 0000 0000 0000 0000 0001
//-1 反码 1111 1111 1111 1111 1111 1111 1111 1110
//-1 补码 1111 1111 1111 1111 1111 1111 1111 1111
//-255原码 1000 0000 0000 0000 0000 0000  ‭1111 1111‬
//-255反码 1111 1111 1111 1111 1111 1111 0000 0000
//-255补码 1111 1111 1111 1111 1111 1111 0000 0001
//*********************************************************************************************************
//-255补码 1111 1111 1111 1111 1111 1111 0000 0001
//-1 补码  1111 1111 1111 1111 1111 1111 1111 1111
//相加   因为相加之后得到的是char 类型 因此必须进行截断  恰好 0000 0000最高位溢出
//例7.
//#include <stdio.h>
//#include <stdlib.h>
//
//int main(){
//
//	unsigned char i = 0;
//	for (i = 0; i <= 255;i++){
//		printf("hehe\n");
//	}
//
//
//	system("pause");
//	return 0;
//
//}
//结果是死循环
//判定i取最大值时i的值 unsigned char 占一个字节大小
//i++  = i+=1 = i=i+1
//i=255 ‭1111 1111‬
//1     0000 0001
//二者相加等于0,又重新进入循环
//****2. 浮点数在内存中的存储
//例1.
//#include <stdio.h>
//#include <stdlib.h>
//
//int main(){
//	int n = 9;
//	int* p = &n;
//	//等于将int*(4个字节)强制转化成float*(4个字节)
//	float* p2 = (float*)p;
//
//	printf("%f\n",*p2);
//	system("pause");
//	return 0;
//}
//代码不符合规范
//对于浮点数而言,把一个整数对应的内存空间按照float来解析,会导致结果出现错误.
//例2.浮点型的拓展以及注意事项
//写代码的时候不能用 == 进行2个浮点数的比较,看差值是否小于一个预期的误差范围就可以了
//#include <stdio.h>
//#include <stdlib.h>
//
////宏定义
//#define E 1e-4
//
//int main(){
//
//	float i = 19.0;
//	float j =i/7.0;
//	if (j*7.0 - i > -E && j*7.0 - i < E){
//		printf("相等\n");
//	}
//	else {
//		printf("不相等\n");
//	}
//	system("pause");
//	return 0;
//}
//相等
//**********************************************************************************************************
//******************指针进阶******************
//举例1.
//#include <stdio.h>
//#include <stdlib.h>
//
//int main(){
//
//	char str1[] = "hello";
//	char str2[] = "hello";
//
//	char* str3 = "hello";
//	char* str4 = "hello";
//	//两个数组不能直接比较 ,但是指针可以,在某些情况下数组能隐式转化为指针,指向首元素的地址
//	if (str1 == str2){
//		printf("相等\n");
//	}
//	else{
//		printf("不相等\n");
//	}
//	//上面情况等于将字符串常量赋值到str1中
//	if (str3 == str4){
//		printf("相等\n");
//	}
//	else{
//		printf("不相等\n");
//	}
//
//	//单纯指针的赋值
//	system("pause");
//	return 0;
//
//}
// == 比较两个字符串的身份/地址 
//************************************************************************************************************
//例2.
#include <stdio.h>
#include <stdlib.h>

int main(){
	char str1[] = "hello";
	str1[0] = 'a';
	printf("%s\n",str1); // aello

	/*char* str2 = "hello";
	str2[0] = 'a';//修改字符串本身(因此出错)  "hello"处于常量区,常量不能修改,因此导致程序崩溃
	printf("%s\n", str2);*/
	//


	system("pause");
	return 0;

}























































































































































































































































































