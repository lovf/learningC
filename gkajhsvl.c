//例4.斐波那契数(生兔子问题)
//1  1  2  3  5  8  13  21 .........()始终满足前两项之和等于第三项
//法1.递归(函数调用)计算方法比递归快很多避免了重复计算
//#include <stdio.h>
//#include <stdlib.h>
//
//int Fib(int n){
//	int last1 = 1;
//	int last2 = 1;
//	int cur;
//	int i;
//	if (n <= 2){
//		return 1;;
//	}
//	if (n >= 3){
//	for (i = 3; i <= n; i++){
//		cur = last1 + last2;
//		last2 = last1;
//		last1 = cur;
//	}
//	return cur;
//  }
//}
//	int main(){
//	printf ("%d\n",Fib(6));
//	system("pause");
//	return 0;
//}
//*************************************************************************************
//法2.递归
#include <stdio.h>
#include <stdlib.h>


int Fib(int n){
	if (n <= 2){
		return 1;
	}
	return Fib(n - 1) + Fib(n - 2);
}
int main(){
	printf("%d\n",Fib(6));
	system("pause");
	return 0;
}
//****************************************************************************************
//函数递归就是把问题进行拆分,然后递归进行求解.
//递归:程序调用自身的编程技巧.递归的两个必要条件.
//1.存在限制条件,当满足这个限制条件的时候,递归将不再继续进行下去.
//2.每次递归调用之后越来越接近这个限制条件.(收敛)